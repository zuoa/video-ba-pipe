{% extends "base.html" %}

{% block title %}算法编排管理{% endblock %}
{% block page_title %}算法编排管理{% endblock %}
{% block page_subtitle %}可视化配置视频分析算法编排{% endblock %}

{% block content %}
<div class="max-w-full mx-auto">
    <!-- 算法编排列表 -->
    <div id="workflowList" class="mb-6">
        <div class="flex justify-between items-center mb-4">
            <div class="flex items-center space-x-4">
                <div class="w-12 h-12 bg-black rounded-xl flex items-center justify-center text-white shadow-lg">
                    <i class="fas fa-project-diagram text-xl"></i>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-800">算法编排列表</h3>
                    <p class="text-sm text-gray-500" id="workflowCount">共 0 个算法编排</p>
                </div>
            </div>
            <button onclick="showCreateModal()" class="btn-primary text-white px-6 py-3 rounded-lg font-medium shadow-lg flex items-center space-x-2 hover:shadow-xl">
                <i class="fas fa-plus"></i>
                <span>新建算法编排</span>
            </button>
        </div>

        <div class="bg-white rounded-2xl shadow-xl overflow-hidden border border-gray-100">
            <div class="overflow-x-auto custom-scrollbar">
                <table class="min-w-full divide-y divide-gray-100">
                    <thead class="bg-gradient-to-r from-gray-50 to-gray-100">
                        <tr>
                            <th class="px-6 py-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">名称</th>
                            <th class="px-6 py-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">描述</th>
                            <th class="px-6 py-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">状态</th>
                            <th class="px-6 py-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">更新时间</th>
                            <th class="px-6 py-4 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">操作</th>
                        </tr>
                    </thead>
                    <tbody id="workflowsTable" class="bg-white divide-y divide-gray-100">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<!-- 创建/编辑算法编排模态框 -->
<div id="workflowModal" class="hidden fixed inset-0 bg-black bg-opacity-50 overflow-y-auto h-full w-full z-50 backdrop-blur-sm">
    <div class="relative top-10 mx-auto p-8 border border-gray-200 w-11/12 md:w-1/2 shadow-2xl rounded-2xl bg-white">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-2xl font-bold text-gray-800" id="modalTitle">新建算法编排</h3>
            <button onclick="closeWorkflowModal()" class="text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded-lg p-2 transition-all">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>

        <form id="workflowForm" onsubmit="handleWorkflowSubmit(event)" class="space-y-6">
            <input type="hidden" id="workflowId">
            
            <div>
                <label class="block text-gray-700 text-sm font-semibold mb-2">算法编排名称 *</label>
                <input type="text" id="workflowName" required placeholder="例如: 门口监控算法编排"
                    class="w-full px-4 py-3 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-black focus:border-transparent transition-all">
            </div>

            <div>
                <label class="block text-gray-700 text-sm font-semibold mb-2">描述</label>
                <textarea id="workflowDescription" rows="3" placeholder="描述算法编排的用途"
                    class="w-full px-4 py-3 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-black focus:border-transparent transition-all"></textarea>
            </div>

            <div class="flex justify-end space-x-3 pt-4 border-t border-gray-100">
                <button type="button" onclick="closeWorkflowModal()" class="px-6 py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium rounded-xl transition-all">
                    取消
                </button>
                <button type="submit" class="px-6 py-3 btn-primary text-white font-medium rounded-xl shadow-lg">
                    <i class="fas fa-check mr-2"></i>创建并编辑
                </button>
            </div>
        </form>
    </div>
</div>

<!-- 算法编排编辑器模态框 -->
<div id="editorModal" class="hidden fixed inset-0 bg-black bg-opacity-50 overflow-hidden h-full w-full z-50">
    <div class="relative w-full h-full bg-white">
        <!-- 编辑器头部 -->
        <div class="flex justify-between items-center p-4 bg-gradient-to-r from-gray-800 to-black text-white shadow-lg">
            <div class="flex items-center space-x-4">
                <i class="fas fa-project-diagram text-2xl"></i>
                <div>
                    <h3 class="text-xl font-bold" id="editorTitle">算法编排编辑器</h3>
                    <p class="text-sm text-gray-300" id="editorSubtitle">拖拽组件到画布，连线配置算法编排</p>
                </div>
            </div>
            <div class="flex items-center space-x-2">
                <button onclick="showTestPanel()" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-medium transition-all flex items-center space-x-2">
                    <i class="fas fa-flask"></i>
                    <span>测试</span>
                </button>
                <button onclick="saveWorkflow()" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-medium transition-all flex items-center space-x-2">
                    <i class="fas fa-save"></i>
                    <span>保存</span>
                </button>
                <button onclick="closeEditor()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-lg font-medium transition-all">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>

        <div class="flex h-[calc(100vh-80px)]">
            <!-- 左侧组件面板 -->
            <div class="w-64 bg-gray-50 border-r border-gray-200 overflow-y-auto p-4">
                <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                    <i class="fas fa-boxes mr-2"></i>组件库
                </h4>
                
                <!-- 视频源组件 -->
                <div class="mb-6">
                    <h5 class="text-xs font-semibold text-gray-600 mb-2">视频源</h5>
                    <div id="sourcesPanel" class="space-y-2">
                        <!-- 动态加载 -->
                    </div>
                </div>

                <!-- 算法组件 -->
                <div class="mb-6">
                    <h5 class="text-xs font-semibold text-gray-600 mb-2">算法</h5>
                    <div id="algorithmsPanel" class="space-y-2">
                        <!-- 动态加载 -->
                    </div>
                </div>

                <!-- 条件分支 -->
                <div class="mb-6">
                    <h5 class="text-xs font-semibold text-gray-600 mb-2">条件分支</h5>
                    <div class="space-y-2">
                        <div class="component-item p-3 bg-white border-2 border-yellow-200 rounded-lg cursor-move hover:shadow-md transition-all"
                            draggable="true"
                            data-type="condition"
                            data-subtype="detection"
                            ondragstart="handleDragStart(event)">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-code-branch text-yellow-500"></i>
                                <div class="flex-1 min-w-0">
                                    <div class="text-sm font-medium text-gray-700">检测条件</div>
                                    <div class="text-xs text-gray-500">是/否检测到</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 图像处理 -->
                <div class="mb-6">
                    <h5 class="text-xs font-semibold text-gray-600 mb-2">图像处理</h5>
                    <div class="space-y-2">
                        <div class="component-item p-3 bg-white border-2 border-orange-200 rounded-lg cursor-move hover:shadow-md transition-all"
                            draggable="true"
                            data-type="roi"
                            data-subtype="draw"
                            data-name="热区绘制"
                            ondragstart="handleDragStart(event)">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-draw-polygon text-orange-500"></i>
                                <div class="flex-1 min-w-0">
                                    <div class="text-sm font-medium text-gray-700">热区绘制</div>
                                    <div class="text-xs text-gray-500">绘制ROI区域</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 输出组件 -->
                <div>
                    <h5 class="text-xs font-semibold text-gray-600 mb-2">输出</h5>
                    <div class="space-y-2">
                        <div class="component-item p-3 bg-white border-2 border-purple-200 rounded-lg cursor-move hover:shadow-md transition-all"
                            draggable="true" 
                            data-type="output"
                            data-subtype="alert"
                            ondragstart="handleDragStart(event)">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-bell text-purple-500"></i>
                                <span class="text-sm font-medium text-gray-700">告警输出</span>
                            </div>
                        </div>
                        <div class="component-item p-3 bg-white border-2 border-purple-200 rounded-lg cursor-move hover:shadow-md transition-all"
                            draggable="true" 
                            data-type="output"
                            data-subtype="record"
                            ondragstart="handleDragStart(event)">
                            <div class="flex items-center space-x-2">
                                <i class="fas fa-video text-purple-500"></i>
                                <span class="text-sm font-medium text-gray-700">录像输出</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 中间画布 -->
            <div class="flex-1 relative bg-gray-100 overflow-hidden">
                <div id="canvas" class="w-full h-full relative"
                    ondrop="handleDrop(event)"
                    ondragover="handleDragOver(event)">
                    <!-- SVG 用于绘制连线 -->
                    <svg id="connectionsSvg" class="absolute inset-0 w-full h-full pointer-events-none" style="z-index: 1;">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                <polygon points="0 0, 10 3, 0 6" fill="#4B5563" />
                            </marker>
                        </defs>
                    </svg>
                    <!-- 节点容器 -->
                    <div id="nodesContainer" class="absolute inset-0" style="z-index: 2;"></div>
                    
                    <!-- 空状态提示 -->
                    <div id="emptyState" class="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <div class="text-center text-gray-400">
                            <i class="fas fa-mouse-pointer text-6xl mb-4"></i>
                            <p class="text-lg font-medium">从左侧拖拽组件到此处开始配置算法编排</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 右侧属性/测试面板 -->
            <div class="w-80 bg-gray-50 border-l border-gray-200 overflow-y-auto p-4">
                <!-- 切换标签 -->
                <div class="flex mb-4 bg-white rounded-lg p-1">
                    <button onclick="switchRightPanel('properties')" id="tabProperties" class="flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all bg-black text-white">
                        <i class="fas fa-sliders-h mr-2"></i>属性
                    </button>
                    <button onclick="switchRightPanel('test')" id="tabTest" class="flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all text-gray-600 hover:bg-gray-100">
                        <i class="fas fa-flask mr-2"></i>测试
                    </button>
                </div>
                
                <!-- 属性面板 -->
                <div id="propertiesPanel">
                    <div class="text-center text-gray-400 py-8">
                        <i class="fas fa-hand-pointer text-4xl mb-3"></i>
                        <p class="text-sm">点击节点查看属性</p>
                    </div>
                </div>
                
                <!-- 测试面板 -->
                <div id="testPanel" class="hidden">
                    <h4 class="text-sm font-bold text-gray-700 mb-4 flex items-center">
                        <i class="fas fa-flask mr-2"></i>算法编排测试
                    </h4>
                    
                    <!-- 图片来源选择 -->
                    <div class="mb-4">
                        <label class="block text-xs font-semibold text-gray-600 mb-2">图片来源</label>
                        <div class="flex space-x-2 bg-gray-100 rounded-lg p-1">
                            <button onclick="switchImageSource('upload')" id="btnSourceUpload" class="flex-1 px-3 py-2 text-xs font-medium rounded-lg transition-all bg-white shadow">
                                <i class="fas fa-upload mr-1"></i>上传图片
                            </button>
                            <button onclick="switchImageSource('video')" id="btnSourceVideo" class="flex-1 px-3 py-2 text-xs font-medium rounded-lg transition-all text-gray-600 hover:bg-white">
                                <i class="fas fa-video mr-1"></i>视频源
                            </button>
                        </div>
                    </div>
                    
                    <!-- 上传图片区域 -->
                    <div id="uploadImageArea" class="mb-4">
                        <label class="block text-xs font-semibold text-gray-600 mb-2">上传测试图片</label>
                        <div class="border-2 border-dashed border-gray-300 rounded-lg p-4 text-center hover:border-blue-400 transition-all cursor-pointer"
                            onclick="document.getElementById('testImageInput').click()">
                            <input type="file" id="testImageInput" accept="image/*" class="hidden" onchange="handleTestImageUpload(event)">
                            <i class="fas fa-cloud-upload text-3xl text-gray-400 mb-2"></i>
                            <p class="text-xs text-gray-500">点击上传测试图片</p>
                        </div>
                    </div>
                    
                    <!-- 从视频源读取区域 -->
                    <div id="videoSourceArea" class="mb-4 hidden">
                        <label class="block text-xs font-semibold text-gray-600 mb-2">选择视频源</label>
                        <select id="videoSourceSelect" class="w-full px-3 py-2 border border-gray-200 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-black mb-2">
                            <option value="">-- 请选择视频源 --</option>
                        </select>
                        <button onclick="captureFrameFromVideo()" id="btnCaptureFrame" class="w-full px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-medium text-sm transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                            <i class="fas fa-camera mr-2"></i>抓取当前帧
                        </button>
                    </div>
                    
                    <!-- 图片预览区域 -->
                    <div id="testImagePreview" class="mb-4 hidden">
                        <label class="block text-xs font-semibold text-gray-600 mb-2">测试图片预览</label>
                        <div class="relative">
                            <img id="testImagePreviewImg" src="" class="w-full rounded-lg shadow-sm border border-gray-200">
                            <div id="imageSourceBadge" class="absolute top-2 right-2 px-2 py-1 bg-black bg-opacity-70 text-white text-xs rounded"></div>
                        </div>
                        <button onclick="clearTestImage()" class="mt-2 w-full px-3 py-2 bg-red-50 text-red-600 rounded-lg text-xs hover:bg-red-100 transition-all">
                            <i class="fas fa-trash mr-1"></i>清除图片
                        </button>
                    </div>
                    
                    <!-- 测试按钮 -->
                    <button onclick="runWorkflowTest()" id="runTestBtn" class="w-full px-4 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-medium transition-all mb-4 disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fas fa-play mr-2"></i>运行测试
                    </button>
                    
                    <!-- 测试结果 -->
                    <div id="testResults" class="hidden">
                        <div class="bg-white rounded-lg p-3 mb-3 border border-gray-200">
                            <div class="flex items-center justify-between mb-2">
                                <h5 class="text-xs font-bold text-gray-700">测试结果</h5>
                                <span id="testStatus" class="text-xs px-2 py-1 rounded-full"></span>
                            </div>
                            <div id="testResultContent" class="text-xs text-gray-600"></div>
                        </div>
                        
                        <!-- 节点执行详情 -->
                        <div id="nodeExecutionDetails" class="space-y-2"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block styles %}
<style>
    .component-item {
        transition: all 0.2s ease;
    }
    
    .component-item:hover {
        transform: translateY(-2px);
    }
    
    .workflow-node {
        position: absolute;
        min-width: 180px;
        background: white;
        border: 2px solid #E5E7EB;
        border-radius: 12px;
        padding: 16px;
        cursor: move;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
    }
    
    .workflow-node:hover {
        box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
        border-color: #3B82F6;
    }
    
    .workflow-node.selected {
        border-color: #3B82F6;
        border-width: 3px;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }
    
    .node-connector {
        position: absolute;
        width: 12px;
        height: 12px;
        background: white;
        border: 2px solid #6B7280;
        border-radius: 50%;
        cursor: crosshair;
        transition: all 0.2s ease;
    }
    
    .node-connector:hover {
        width: 16px;
        height: 16px;
        background: #3B82F6;
        border-color: #3B82F6;
    }
    
    .node-connector.output {
        right: -8px;
        top: 50%;
        transform: translateY(-50%);
    }
    
    .node-connector.input {
        left: -8px;
        top: 50%;
        transform: translateY(-50%);
    }
    
    .connection-line {
        fill: none;
        stroke: #4B5563;
        stroke-width: 2;
        marker-end: url(#arrowhead);
    }
    
    .node-source {
        border-color: #10B981;
    }
    
    .node-algorithm {
        border-color: #3B82F6;
    }
    
    .node-output {
        border-color: #8B5CF6;
    }
    
    .node-condition {
        border-color: #F59E0B;
    }

    .node-roi {
        border-color: #F97316;
    }

    .connection-line.detected {
        stroke: #10B981;
    }
    
    .connection-line.not-detected {
        stroke: #EF4444;
    }
    
    .connection-label {
        font-size: 11px;
        fill: white;
        font-weight: 600;
    }
    
    .connection-label-bg {
        fill: #4B5563;
        rx: 4;
    }
    
    .connection-label-bg.detected {
        fill: #10B981;
    }
    
    .connection-label-bg.not-detected {
        fill: #EF4444;
    }
    
    .node-testing {
        animation: pulse-blue 1s infinite;
    }
    
    .node-success {
        border-color: #10B981 !important;
        box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
    }
    
    .node-error {
        border-color: #EF4444 !important;
        box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2);
    }
    
    @keyframes pulse-blue {
        0%, 100% {
            box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
        }
        50% {
            box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
        }
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    let workflows = [];
    let currentWorkflow = null;
    let nodes = [];
    let connections = [];
    let selectedNode = null;
    let draggedNode = null;
    let isConnecting = false;
    let connectionStart = null;
    let resources = { sources: [], algorithms: [] };
    let nodeIdCounter = 0;
    let testImageData = null;
    let currentRightPanel = 'properties';
    let currentImageSource = 'upload';  // 'upload' 或 'video'

    // 切换图片来源
    function switchImageSource(source) {
        currentImageSource = source;
        
        // 更新按钮样式
        if (source === 'upload') {
            document.getElementById('btnSourceUpload').className = 'flex-1 px-3 py-2 text-xs font-medium rounded-lg transition-all bg-white shadow';
            document.getElementById('btnSourceVideo').className = 'flex-1 px-3 py-2 text-xs font-medium rounded-lg transition-all text-gray-600 hover:bg-white';
            
            document.getElementById('uploadImageArea').classList.remove('hidden');
            document.getElementById('videoSourceArea').classList.add('hidden');
        } else {
            document.getElementById('btnSourceUpload').className = 'flex-1 px-3 py-2 text-xs font-medium rounded-lg transition-all text-gray-600 hover:bg-white';
            document.getElementById('btnSourceVideo').className = 'flex-1 px-3 py-2 text-xs font-medium rounded-lg transition-all bg-white shadow';
            
            document.getElementById('uploadImageArea').classList.add('hidden');
            document.getElementById('videoSourceArea').classList.remove('hidden');
        }
    }

    // 从视频源抓取图片
    async function captureFrameFromVideo() {
        const selectEl = document.getElementById('videoSourceSelect');
        const taskId = selectEl.value;
        
        if (!taskId) {
            showMessage('请先选择视频源', 'warning');
            return;
        }
        
        const btnCapture = document.getElementById('btnCaptureFrame');
        btnCapture.disabled = true;
        btnCapture.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>抓取中...';
        
        try {
            const response = await fetch(`/api/workflows/capture_frame/${taskId}`);
            const result = await response.json();
            
            if (!response.ok) {
                throw new Error(result.error || '抓取失败');
            }
            
            // 设置图片数据
            testImageData = result.image;
            document.getElementById('testImagePreviewImg').src = testImageData;
            document.getElementById('testImagePreview').classList.remove('hidden');
            
            // 显示来源标记
            const badge = document.getElementById('imageSourceBadge');
            const taskName = result.task_name || '视频源';
            const sourceType = result.source === 'snapshot' ? '快照' : '实时';
            badge.textContent = `${taskName} (${sourceType})`;
            
            document.getElementById('runTestBtn').disabled = false;
            
            showMessage('成功抓取视频帧', 'success');
        } catch (error) {
            showMessage('抓取失败: ' + error.message, 'error');
        } finally {
            btnCapture.disabled = false;
            btnCapture.innerHTML = '<i class="fas fa-camera mr-2"></i>抓取当前帧';
        }
    }

    // 切换右侧面板
    function switchRightPanel(panel) {
        currentRightPanel = panel;
        
        if (panel === 'properties') {
            document.getElementById('propertiesPanel').classList.remove('hidden');
            document.getElementById('testPanel').classList.add('hidden');
            document.getElementById('tabProperties').className = 'flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all bg-black text-white';
            document.getElementById('tabTest').className = 'flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all text-gray-600 hover:bg-gray-100';
        } else {
            document.getElementById('propertiesPanel').classList.add('hidden');
            document.getElementById('testPanel').classList.remove('hidden');
            document.getElementById('tabProperties').className = 'flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all text-gray-600 hover:bg-gray-100';
            document.getElementById('tabTest').className = 'flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all bg-black text-white';
        }
    }

    function showTestPanel() {
        switchRightPanel('test');
    }

    // 处理测试图片上传
    function handleTestImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            testImageData = e.target.result;
            document.getElementById('testImagePreviewImg').src = testImageData;
            document.getElementById('testImagePreview').classList.remove('hidden');
            
            // 显示来源标记
            const badge = document.getElementById('imageSourceBadge');
            badge.textContent = `上传: ${file.name}`;
            
            document.getElementById('runTestBtn').disabled = false;
        };
        reader.readAsDataURL(file);
    }

    function clearTestImage() {
        testImageData = null;
        document.getElementById('testImageInput').value = '';
        document.getElementById('videoSourceSelect').value = '';
        document.getElementById('testImagePreview').classList.add('hidden');
        document.getElementById('runTestBtn').disabled = true;
        document.getElementById('testResults').classList.add('hidden');
    }

    // 运行算法编排测试
    async function runWorkflowTest() {
        if (!testImageData) {
            showMessage('请先上传测试图片', 'warning');
            return;
        }
        
        if (nodes.length === 0) {
            showMessage('算法编排为空，请先添加节点', 'warning');
            return;
        }
        
        // 验证算法编排
        const validation = validateWorkflow();
        if (!validation.valid) {
            showMessage('算法编排配置错误: ' + validation.error, 'error');
            return;
        }
        
        const runTestBtn = document.getElementById('runTestBtn');
        runTestBtn.disabled = true;
        runTestBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>测试中...';
        
        try {
            // 清除之前的测试状态
            clearTestStates();
            
            // 显示测试结果面板
            document.getElementById('testResults').classList.remove('hidden');
            
            // 执行测试
            const result = await executeWorkflowTest();
            
            // 显示测试结果
            displayTestResults(result);
            
        } catch (error) {
            showMessage('测试失败: ' + error.message, 'error');
            displayTestError(error);
        } finally {
            runTestBtn.disabled = false;
            runTestBtn.innerHTML = '<i class="fas fa-play mr-2"></i>运行测试';
        }
    }

    // 验证算法编排配置
    function validateWorkflow() {
        // 检查是否有源节点
        const sourceNodes = nodes.filter(n => n.type === 'source');
        if (sourceNodes.length === 0) {
            return { valid: false, error: '缺少视频源节点' };
        }
        
        // 检查是否有输出节点
        const outputNodes = nodes.filter(n => n.type === 'output');
        if (outputNodes.length === 0) {
            return { valid: false, error: '缺少输出节点' };
        }
        
        // 检查连线
        if (connections.length === 0) {
            return { valid: false, error: '节点未连接' };
        }
        
        return { valid: true };
    }

    // 清除测试状态
    function clearTestStates() {
        document.querySelectorAll('.workflow-node').forEach(node => {
            node.classList.remove('node-testing', 'node-success', 'node-error');
        });
    }

    // 执行算法编排测试（模拟）
    async function executeWorkflowTest() {
        const executionOrder = getExecutionOrder();
        const results = {
            success: true,
            nodes: [],
            totalTime: 0
        };
        
        // 维护已执行节点的结果映射
        const executedResults = new Map();
        
        // 记录应该跳过的节点（不满足条件分支的节点）
        const skipNodes = new Set();
        
        for (const nodeId of executionOrder) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) continue;
            
            // 如果节点被标记为跳过，则不执行
            if (skipNodes.has(nodeId)) {
                console.log(`跳过节点: ${node.name} (不满足条件分支)`);
                continue;
            }
            
            // 标记节点为测试中
            markNodeTesting(nodeId);
            
            // 模拟节点执行
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // 执行节点
            try {
                const nodeResult = await executeNode(node, executedResults);
                results.nodes.push(nodeResult);
                executedResults.set(nodeId, nodeResult);
                
                if (nodeResult.success) {
                    markNodeSuccess(nodeId);
                    
                    // 如果是条件节点，根据结果决定后续哪些节点需要跳过
                    if (node.type === 'condition') {
                        const conditionResult = nodeResult.data.condition; // 'detected' 或 'not_detected'
                        
                        // 查找从该条件节点出发的所有连线
                        const outgoingConnections = connections.filter(c => c.from === nodeId);
                        
                        for (const conn of outgoingConnections) {
                            // 如果连线的条件与当前结果不匹配，标记目标节点及其所有后续节点为跳过
                            if (conn.condition && conn.condition !== conditionResult) {
                                markNodeAndDescendantsToSkip(conn.to, skipNodes);
                            }
                        }
                    }
                } else {
                    markNodeError(nodeId);
                    results.success = false;
                    break;
                }
            } catch (error) {
                markNodeError(nodeId);
                results.nodes.push({
                    nodeId: nodeId,
                    nodeName: node.name,
                    success: false,
                    error: error.message
                });
                results.success = false;
                break;
            }
        }
        
        return results;
    }
    
    // 标记节点及其所有后续节点为跳过
    function markNodeAndDescendantsToSkip(nodeId, skipNodes) {
        if (skipNodes.has(nodeId)) return;
        
        skipNodes.add(nodeId);
        
        // 递归标记所有后续节点
        const outgoingConnections = connections.filter(c => c.from === nodeId);
        for (const conn of outgoingConnections) {
            markNodeAndDescendantsToSkip(conn.to, skipNodes);
        }
    }

    // 获取执行顺序（拓扑排序）
    function getExecutionOrder() {
        const order = [];
        const visited = new Set();
        const visiting = new Set();
        
        function visit(nodeId) {
            if (visited.has(nodeId)) return;
            if (visiting.has(nodeId)) {
                throw new Error('检测到循环依赖');
            }
            
            visiting.add(nodeId);
            
            // 访问所有前置节点
            const incomingConnections = connections.filter(c => c.to === nodeId);
            for (const conn of incomingConnections) {
                visit(conn.from);
            }
            
            visiting.delete(nodeId);
            visited.add(nodeId);
            order.push(nodeId);
        }
        
        // 从所有节点开始访问
        for (const node of nodes) {
            if (!visited.has(node.id)) {
                visit(node.id);
            }
        }
        
        return order;
    }

    // 执行单个节点
    async function executeNode(node, executedResults) {
        const startTime = Date.now();
        
        let result = {
            nodeId: node.id,
            nodeName: node.name,
            nodeType: node.type,
            success: true,
            executionTime: 0,
            data: {}
        };
        
        try {
            switch (node.type) {
                case 'source':
                    result.data = {
                        message: '视频源加载成功',
                        resolution: '1920x1080',
                        fps: 25
                    };
                    break;
                    
                case 'algorithm':
                    // 调用实际的算法测试API
                    if (node.dataId) {
                        const apiResult = await testAlgorithmWithImage(node.dataId, testImageData);
                        result.data = {
                            detections: apiResult.detections || [],
                            detection_count: apiResult.detection_count || 0,
                            confidence: apiResult.confidence || 0,
                            result_image: apiResult.result_image
                        };
                    } else {
                        result.data = {
                            message: '算法节点（模拟）',
                            detections: [],
                            detection_count: 0
                        };
                    }
                    break;
                    
                case 'condition':
                    // 根据前置节点的检测结果判断
                    const prevNode = getPreviousNodeResult(node.id, executedResults);
                    const detected = prevNode && prevNode.data && prevNode.data.detection_count > 0;
                    result.data = {
                        condition: detected ? 'detected' : 'not_detected',
                        message: detected ? '检测到目标' : '未检测到目标',
                        branch: detected ? '是' : '否'
                    };
                    break;

                case 'roi':
                    // 热区绘制节点，只记录ROI坐标
                    const roiConfig = node.data?.roi_regions?.[0];
                    if (roiConfig) {
                        result.data = {
                            message: '热区绘制成功',
                            roi_region: {
                                x: roiConfig.x,
                                y: roiConfig.y,
                                width: roiConfig.width,
                                height: roiConfig.height,
                                polygon: roiConfig.polygon
                            },
                            polygon_points: roiConfig.polygon ? roiConfig.polygon.length : 0
                        };
                    } else {
                        result.data = {
                            message: '未配置ROI区域（模拟）',
                            roi_region: null
                        };
                    }
                    break;

                case 'output':
                    result.data = {
                        message: node.subtype === 'alert' ? '告警已触发' : '录像已保存',
                        outputType: node.subtype
                    };
                    break;
            }
        } catch (error) {
            result.success = false;
            result.error = error.message;
        }
        
        result.executionTime = Date.now() - startTime;
        return result;
    }

    // 获取前置节点的结果
    function getPreviousNodeResult(nodeId, executedResults) {
        // 查找直接连接到当前节点的前置节点
        const incomingConnection = connections.find(c => c.to === nodeId);
        if (!incomingConnection) {
            return null;
        }
        
        // 从已执行结果中查找前置节点的结果
        const prevNodeId = incomingConnection.from;
        return executedResults.get(prevNodeId) || null;
    }

    // 调用算法测试API
    async function testAlgorithmWithImage(algorithmId, imageData) {
        try {
            // 将base64转换为blob
            const response = await fetch(imageData);
            const blob = await response.blob();
            
            // 创建FormData
            const formData = new FormData();
            formData.append('image', blob, 'test.jpg');
            formData.append('algorithm_id', algorithmId);
            
            // 调用测试API
            const result = await fetch('/api/algorithms/test', {
                method: 'POST',
                body: formData
            });
            
            if (!result.ok) {
                throw new Error('算法测试失败');
            }
            
            return await result.json();
        } catch (error) {
            console.error('算法测试错误:', error);
            return {
                success: false,
                detections: [],
                detection_count: 0
            };
        }
    }

    // 标记节点状态
    function markNodeTesting(nodeId) {
        const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeEl) {
            nodeEl.classList.add('node-testing');
        }
    }

    function markNodeSuccess(nodeId) {
        const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeEl) {
            nodeEl.classList.remove('node-testing');
            nodeEl.classList.add('node-success');
        }
    }

    function markNodeError(nodeId) {
        const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeEl) {
            nodeEl.classList.remove('node-testing');
            nodeEl.classList.add('node-error');
        }
    }

    // 显示测试结果
    function displayTestResults(results) {
        const statusEl = document.getElementById('testStatus');
        const contentEl = document.getElementById('testResultContent');
        const detailsEl = document.getElementById('nodeExecutionDetails');
        
        if (results.success) {
            statusEl.className = 'text-xs px-2 py-1 rounded-full bg-green-100 text-green-700';
            statusEl.textContent = '测试通过';
            contentEl.innerHTML = `
                <div class="text-sm">
                    <p class="mb-1">✓ 所有节点执行成功</p>
                    <p class="text-gray-500">共执行 ${results.nodes.length} 个节点</p>
                </div>
            `;
        } else {
            statusEl.className = 'text-xs px-2 py-1 rounded-full bg-red-100 text-red-700';
            statusEl.textContent = '测试失败';
            contentEl.innerHTML = `
                <div class="text-sm">
                    <p class="mb-1">✗ 测试过程中出现错误</p>
                    <p class="text-gray-500">执行了 ${results.nodes.length} 个节点</p>
                </div>
            `;
        }
        
        // 显示节点执行详情
        detailsEl.innerHTML = results.nodes.map(node => `
            <div class="bg-white rounded-lg p-3 border ${node.success ? 'border-green-200' : 'border-red-200'}">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center space-x-2">
                        <i class="fas ${node.success ? 'fa-check-circle text-green-500' : 'fa-times-circle text-red-500'}"></i>
                        <span class="text-xs font-bold text-gray-700">${node.nodeName}</span>
                    </div>
                    <span class="text-xs text-gray-500">${node.executionTime}ms</span>
                </div>
                <div class="text-xs text-gray-600">
                    ${node.success ? formatNodeData(node) : `<p class="text-red-600">错误: ${node.error}</p>`}
                </div>
                ${node.data && node.data.result_image ? `
                    <div class="mt-2">
                        <img src="${node.data.result_image}" class="w-full rounded-lg shadow-sm">
                    </div>
                ` : ''}
            </div>
        `).join('');
    }

    function formatNodeData(node) {
        const data = node.data;

        switch (node.nodeType) {
            case 'source':
                return `<p>✓ ${data.message}</p><p class="text-gray-500">分辨率: ${data.resolution}, 帧率: ${data.fps}</p>`;

            case 'algorithm':
                if (data.detection_count > 0) {
                    return `<p>✓ 检测到 ${data.detection_count} 个目标</p>`;
                } else {
                    return `<p>未检测到目标</p>`;
                }

            case 'condition':
                return `<p>✓ ${data.message}</p><p class="text-gray-500">执行分支: ${data.branch}</p>`;

            case 'crop':
                if (data.crop_region) {
                    return `<p>✓ ${data.message}</p><p class="text-gray-500">裁剪区域: ${data.crop_region.x},${data.crop_region.y} ${data.crop_region.width}x${data.crop_region.height}</p><p class="text-gray-500">输出尺寸: ${data.cropped_size}</p>`;
                } else {
                    return `<p>${data.message}</p>`;
                }

            case 'output':
                return `<p>✓ ${data.message}</p>`;

            default:
                return `<p>${data.message || '执行成功'}</p>`;
        }
    }

    function displayTestError(error) {
        const statusEl = document.getElementById('testStatus');
        const contentEl = document.getElementById('testResultContent');
        
        statusEl.className = 'text-xs px-2 py-1 rounded-full bg-red-100 text-red-700';
        statusEl.textContent = '测试失败';
        contentEl.innerHTML = `
            <div class="text-sm text-red-600">
                <p>✗ ${error.message}</p>
            </div>
        `;
        
        document.getElementById('testResults').classList.remove('hidden');
    }

    // 加载算法编排列表
    async function loadWorkflows() {
        try {
            workflows = await apiRequest('/api/workflows');
            renderWorkflowsTable();
        } catch (error) {
            showMessage('加载算法编排失败: ' + error.message, 'error');
        }
    }

    function renderWorkflowsTable() {
        const tbody = document.getElementById('workflowsTable');
        const count = document.getElementById('workflowCount');
        count.textContent = `共 ${workflows.length} 个算法编排`;
        
        tbody.innerHTML = workflows.map(w => `
            <tr class="hover:bg-gray-50 transition-all duration-200">
                <td class="px-6 py-5 whitespace-nowrap">
                    <div class="flex items-center">
                        <div class="w-10 h-10 bg-black rounded-lg flex items-center justify-center text-white mr-3">
                            <i class="fas fa-project-diagram"></i>
                        </div>
                        <div class="font-semibold text-gray-800">${w.name}</div>
                    </div>
                </td>
                <td class="px-6 py-5">
                    <div class="text-sm text-gray-600">${w.description || '无描述'}</div>
                </td>
                <td class="px-6 py-5 whitespace-nowrap">
                    <span class="inline-flex items-center px-3 py-1.5 rounded-lg ${w.is_active ? 'bg-green-100 text-green-700 border border-green-300' : 'bg-gray-100 text-gray-700 border border-gray-300'} font-medium text-xs">
                        <span class="w-2 h-2 ${w.is_active ? 'bg-green-500' : 'bg-gray-500'} rounded-full mr-2"></span>
                        ${w.is_active ? '激活' : '未激活'}
                    </span>
                </td>
                <td class="px-6 py-5 whitespace-nowrap text-sm text-gray-600">
                    ${w.updated_at ? new Date(w.updated_at).toLocaleString('zh-CN') : '-'}
                </td>
                <td class="px-6 py-5 whitespace-nowrap">
                    <div class="flex items-center space-x-2">
                        <button onclick="editWorkflow(${w.id})" class="px-3 py-2 bg-blue-50 text-blue-600 rounded-lg hover:bg-blue-100 transition-all font-medium text-sm">
                            <i class="fas fa-edit mr-1"></i>编辑
                        </button>
                        ${!w.is_active ? `
                            <button onclick="activateWorkflow(${w.id})" class="px-3 py-2 bg-green-50 text-green-600 rounded-lg hover:bg-green-100 transition-all font-medium text-sm">
                                <i class="fas fa-play mr-1"></i>激活
                            </button>
                        ` : `
                            <button onclick="deactivateWorkflow(${w.id})" class="px-3 py-2 bg-yellow-50 text-yellow-600 rounded-lg hover:bg-yellow-100 transition-all font-medium text-sm">
                                <i class="fas fa-pause mr-1"></i>停用
                            </button>
                        `}
                        <button onclick="deleteWorkflow(${w.id})" class="px-3 py-2 bg-red-50 text-red-600 rounded-lg hover:bg-red-100 transition-all font-medium text-sm">
                            <i class="fas fa-trash mr-1"></i>删除
                        </button>
                    </div>
                </td>
            </tr>
        `).join('');
    }

    function showCreateModal() {
        document.getElementById('modalTitle').textContent = '新建算法编排';
        document.getElementById('workflowForm').reset();
        document.getElementById('workflowId').value = '';
        document.getElementById('workflowModal').classList.remove('hidden');
    }

    function closeWorkflowModal() {
        document.getElementById('workflowModal').classList.add('hidden');
    }

    async function handleWorkflowSubmit(event) {
        event.preventDefault();
        
        const name = document.getElementById('workflowName').value;
        const description = document.getElementById('workflowDescription').value;
        
        try {
            const result = await apiRequest('/api/workflows', 'POST', {
                name: name,
                description: description,
                workflow_data: { nodes: [], connections: [] }
            });
            
            showMessage('算法编排创建成功');
            closeWorkflowModal();
            await loadWorkflows();
            
            // 打开编辑器
            editWorkflow(result.id);
        } catch (error) {
            showMessage('创建失败: ' + error.message, 'error');
        }
    }

    async function editWorkflow(id) {
        try {
            currentWorkflow = await apiRequest(`/api/workflows/${id}`);
            resources = await apiRequest('/api/workflows/resources');
            
            document.getElementById('editorTitle').textContent = currentWorkflow.name;
            document.getElementById('editorSubtitle').textContent = currentWorkflow.description || '配置算法编排';
            
            // 初始化画布
            nodes = currentWorkflow.workflow_data?.nodes || [];
            connections = currentWorkflow.workflow_data?.connections || [];
            
            console.log('加载算法编排数据:', {
                nodes: nodes.length,
                connections: connections.length,
                workflow_data: currentWorkflow.workflow_data
            });
            
            // 更新 nodeIdCounter 避免ID冲突
            if (nodes.length > 0) {
                const maxId = nodes.reduce((max, node) => {
                    const match = node.id.match(/node_(\d+)_/);
                    return match ? Math.max(max, parseInt(match[1])) : max;
                }, 0);
                nodeIdCounter = maxId;
            }
            
            renderComponentPanels();
            renderCanvas();
            
            document.getElementById('editorModal').classList.remove('hidden');
        } catch (error) {
            showMessage('打开编辑器失败: ' + error.message, 'error');
        }
    }

    function renderComponentPanels() {
        // 渲染视频源
        const sourcesPanel = document.getElementById('sourcesPanel');
        sourcesPanel.innerHTML = resources.sources.map(s => `
            <div class="component-item p-3 bg-white border-2 border-green-200 rounded-lg cursor-move hover:shadow-md transition-all"
                draggable="true" 
                data-type="source"
                data-id="${s.id}"
                data-name="${s.name}"
                ondragstart="handleDragStart(event)">
                <div class="flex items-center space-x-2">
                    <i class="fas fa-video text-green-500"></i>
                    <div class="flex-1 min-w-0">
                        <div class="text-sm font-medium text-gray-700 truncate">${s.name}</div>
                        <div class="text-xs text-gray-500 truncate">${s.source_code}</div>
                    </div>
                </div>
            </div>
        `).join('');
        
        // 填充视频源下拉列表（用于测试面板）
        const videoSourceSelect = document.getElementById('videoSourceSelect');
        videoSourceSelect.innerHTML = '<option value="">-- 请选择视频源 --</option>' + 
            resources.sources.map(s => {
                const statusIcon = s.status === 'RUNNING' ? '🟢' : '⚫';
                const statusText = s.status === 'RUNNING' ? '运行中' : '已停止';
                return `<option value="${s.id}">${statusIcon} ${s.name} (${statusText})</option>`;
            }).join('');
        
        // 渲染算法
        const algorithmsPanel = document.getElementById('algorithmsPanel');
        algorithmsPanel.innerHTML = resources.algorithms.map(a => `
            <div class="component-item p-3 bg-white border-2 border-blue-200 rounded-lg cursor-move hover:shadow-md transition-all"
                draggable="true" 
                data-type="algorithm"
                data-id="${a.id}"
                data-name="${a.name}"
                ondragstart="handleDragStart(event)">
                <div class="flex items-center space-x-2">
                    <i class="fas fa-brain text-blue-500"></i>
                    <div class="flex-1 min-w-0">
                        <div class="text-sm font-medium text-gray-700 truncate">${a.name}</div>
                        <div class="text-xs text-gray-500 truncate">${a.label_name}</div>
                    </div>
                </div>
            </div>
        `).join('');
    }

    function renderCanvas() {
        const container = document.getElementById('nodesContainer');
        const svg = document.getElementById('connectionsSvg');
        const emptyState = document.getElementById('emptyState');
        
        // 清空
        container.innerHTML = '';
        // 不在这里清空svg，让renderConnections统一处理
        
        // 显示/隐藏空状态
        emptyState.style.display = nodes.length === 0 ? 'flex' : 'none';
        
        // 渲染节点
        nodes.forEach(node => {
            const nodeEl = createNodeElement(node);
            container.appendChild(nodeEl);
        });
        
        // 延迟渲染连线，确保浏览器完成布局
        requestAnimationFrame(() => {
            renderConnections();
        });
    }

    function createNodeElement(node) {
        const div = document.createElement('div');
        div.className = `workflow-node node-${node.type}`;
        div.style.left = node.x + 'px';
        div.style.top = node.y + 'px';
        div.dataset.nodeId = node.id;
        
        let icon, color, typeLabel;
        switch(node.type) {
            case 'source':
                icon = 'fa-video';
                color = 'text-green-500';
                typeLabel = '视频源';
                break;
            case 'algorithm':
                icon = 'fa-brain';
                color = 'text-blue-500';
                typeLabel = '算法';
                break;
            case 'condition':
                icon = 'fa-code-branch';
                color = 'text-yellow-500';
                typeLabel = '条件分支';
                break;
            case 'roi':
                icon = 'fa-draw-polygon';
                color = 'text-orange-500';
                typeLabel = '热区绘制';
                break;
            case 'output':
                icon = node.subtype === 'alert' ? 'fa-bell' : 'fa-video';
                color = 'text-purple-500';
                typeLabel = '输出';
                break;
        }
        
        // 构建连接点HTML
        let connectorsHtml = '';
        
        // 输入连接点（除了视频源节点）
        if (node.type !== 'source') {
            connectorsHtml += '<div class="node-connector input" data-port="input" onmousedown="startConnection(event, \'' + node.id + '\', \'input\')"></div>';
        }
        
        // 输出连接点（根据节点类型）
        if (node.type === 'condition') {
            // 条件节点有两个输出：是/否
            connectorsHtml += `
                <div class="node-connector output" data-port="true" onmousedown="startConnection(event, '${node.id}', 'true')" 
                    style="right: -8px; top: 30%; background: #10B981; border-color: #10B981;" title="检测到">
                    <span style="position: absolute; right: 20px; top: -2px; font-size: 10px; color: #10B981; font-weight: bold; white-space: nowrap;">是</span>
                </div>
                <div class="node-connector output" data-port="false" onmousedown="startConnection(event, '${node.id}', 'false')" 
                    style="right: -8px; top: 70%; background: #EF4444; border-color: #EF4444;" title="未检测到">
                    <span style="position: absolute; right: 20px; top: -2px; font-size: 10px; color: #EF4444; font-weight: bold; white-space: nowrap;">否</span>
                </div>
            `;
        } else if (node.type !== 'output') {
            // 普通输出连接点（算法可以有多个输出）
            connectorsHtml += '<div class="node-connector output" data-port="output" onmousedown="startConnection(event, \'' + node.id + '\', \'output\')"></div>';
        }
        
        div.innerHTML = `
            <div class="flex items-center justify-between mb-2">
                <div class="flex items-center space-x-2">
                    <i class="fas ${icon} ${color}"></i>
                    <span class="font-semibold text-gray-800 text-sm">${node.name}</span>
                </div>
                <button onclick="deleteNode('${node.id}')" class="text-gray-400 hover:text-red-500">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="text-xs text-gray-500">${typeLabel}</div>
            ${connectorsHtml}
        `;
        
        // 添加拖动和选择事件
        div.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('node-connector')) return;
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'I') return;
            
            selectNode(node.id);
            startNodeDrag(e, node.id);
        });
        
        return div;
    }

    function selectNode(nodeId) {
        // 移除之前的选中状态
        document.querySelectorAll('.workflow-node').forEach(n => n.classList.remove('selected'));
        
        // 添加选中状态
        const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeEl) {
            nodeEl.classList.add('selected');
            selectedNode = nodes.find(n => n.id === nodeId);
            renderPropertiesPanel();
        }
    }

    function renderPropertiesPanel() {
        const panel = document.getElementById('propertiesPanel');

        if (!selectedNode) {
            panel.innerHTML = `
                <div class="text-center text-gray-400 py-8">
                    <i class="fas fa-hand-pointer text-4xl mb-3"></i>
                    <p class="text-sm">点击节点查看属性</p>
                </div>
            `;
            return;
        }

        // 如果切换到roi节点，先清空Canvas状态（避免显示上一个节点的多边形）
        if (selectedNode.type === 'roi') {
            cropPolygonPoints = [];
            cropCanvas = null;
            cropCtx = null;
            cropImage = null;
        }

        // 获取节点配置
        const nodeConfig = selectedNode.data?.config || {};

        panel.innerHTML = `
            <h4 class="text-sm font-bold text-gray-700 mb-4">节点属性</h4>
            <div class="space-y-4">
                <div>
                    <label class="block text-xs font-semibold text-gray-600 mb-1">节点名称</label>
                    <div class="px-3 py-2 bg-gray-100 rounded-lg text-sm text-gray-700">${selectedNode.name}</div>
                </div>
                <div>
                    <label class="block text-xs font-semibold text-gray-600 mb-1">节点类型</label>
                    <div class="px-3 py-2 bg-gray-100 rounded-lg text-sm text-gray-700">${selectedNode.type}</div>
                </div>
                ${selectedNode.dataId ? `
                    <div>
                        <label class="block text-xs font-semibold text-gray-600 mb-1">关联ID</label>
                        <div class="px-3 py-2 bg-gray-100 rounded-lg text-sm text-gray-700">${selectedNode.dataId}</div>
                    </div>
                ` : ''}
                <div>
                    <label class="block text-xs font-semibold text-gray-600 mb-1">位置</label>
                    <div class="px-3 py-2 bg-gray-100 rounded-lg text-sm text-gray-700">X: ${Math.round(selectedNode.x)}, Y: ${Math.round(selectedNode.y)}</div>
                </div>

                ${selectedNode.type === 'algorithm' ? `
                    <div class="border-t border-gray-200 pt-4 mt-4">
                        <h5 class="text-xs font-bold text-gray-700 mb-3 flex items-center">
                            <i class="fas fa-cog mr-2"></i>节点配置
                        </h5>

                        <!-- 窗口检测配置 -->
                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <label class="block text-xs font-semibold text-gray-600">时间窗口检测</label>
                                <button onclick="resetWindowDetectionConfig()" class="text-xs text-blue-600 hover:text-blue-800">重置为默认</button>
                            </div>

                            <div class="space-y-2 bg-gray-50 p-3 rounded-lg">
                                <div class="flex items-center justify-between">
                                    <span class="text-xs text-gray-600">启用窗口检测</span>
                                    <input type="checkbox" id="windowEnable"
                                        ${nodeConfig.window_detection?.enable ? 'checked' : ''}
                                        onchange="updateWindowConfig('enable', this.checked)"
                                        class="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500">
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-600 mb-1">窗口大小（秒）</label>
                                    <input type="number" id="windowSize" min="1" max="300"
                                        value="${nodeConfig.window_detection?.window_size || 30}"
                                        onchange="updateWindowConfig('window_size', parseFloat(this.value))"
                                        class="w-full px-2 py-1 border border-gray-300 rounded text-xs">
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-600 mb-1">检测模式</label>
                                    <select id="windowMode"
                                        onchange="updateWindowConfig('window_mode', this.value)"
                                        class="w-full px-2 py-1 border border-gray-300 rounded text-xs">
                                        <option value="count" ${nodeConfig.window_detection?.window_mode === 'count' ? 'selected' : ''}>检测次数 (count)</option>
                                        <option value="ratio" ${nodeConfig.window_detection?.window_mode === 'ratio' || !nodeConfig.window_detection?.window_mode ? 'selected' : ''}>检测比例 (ratio)</option>
                                        <option value="consecutive" ${nodeConfig.window_detection?.window_mode === 'consecutive' ? 'selected' : ''}>连续检测 (consecutive)</option>
                                    </select>
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-600 mb-1">检测阈值</label>
                                    <input type="number" id="windowThreshold" min="0" max="1" step="0.01"
                                        value="${nodeConfig.window_detection?.window_threshold !== undefined ? nodeConfig.window_detection.window_threshold : 0.3}"
                                        onchange="updateWindowConfig('window_threshold', parseFloat(this.value))"
                                        class="w-full px-2 py-1 border border-gray-300 rounded text-xs">
                                    <p class="text-xs text-gray-500 mt-1">
                                        ${nodeConfig.window_detection?.window_mode === 'count' ? '最少检测次数（整数）' :
                                          nodeConfig.window_detection?.window_mode === 'consecutive' ? '最少连续次数（整数）' :
                                          '最小检测比例（0-1之间的小数）'}
                                    </p>
                                </div>
                            </div>
                        </div>

                        <!-- ROI配置 -->
                        <div class="mb-4">
                            <label class="block text-xs font-semibold text-gray-600 mb-2">ROI区域配置</label>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div id="roiList" class="space-y-2 mb-2">
                                    ${(nodeConfig.roi_regions || []).map((roi, index) => `
                                        <div class="flex items-center justify-between bg-white p-2 rounded border border-gray-200">
                                            <span class="text-xs text-gray-700">${roi.name || '区域' + (index + 1)}</span>
                                            <button onclick="removeROI(${index})" class="text-red-500 hover:text-red-700">
                                                <i class="fas fa-times"></i>
                                            </button>
                                        </div>
                                    `).join('')}
                                </div>
                                <button onclick="addROI()" class="w-full px-3 py-2 bg-blue-50 text-blue-600 rounded-lg text-xs hover:bg-blue-100 transition-all">
                                    <i class="fas fa-plus mr-1"></i>添加ROI区域
                                </button>
                            </div>
                        </div>

                        <!-- 保存按钮 -->
                        <button onclick="saveNodeConfig()" class="w-full px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-medium transition-all">
                            <i class="fas fa-save mr-1"></i>保存配置
                        </button>
                    </div>
                ` : ''}

                ${selectedNode.type === 'roi' ? `
                    <div class="border-t border-gray-200 pt-4 mt-4">
                        <h5 class="text-xs font-bold text-gray-700 mb-3 flex items-center">
                            <i class="fas fa-draw-polygon mr-2"></i>热区绘制配置
                        </h5>

                        <!-- 隐藏的输入框，用于存储配置值 -->
                        <input type="hidden" id="cropX" value="${selectedNode.data?.roi_regions?.[0]?.x || 0}">
                        <input type="hidden" id="cropY" value="${selectedNode.data?.roi_regions?.[0]?.y || 0}">
                        <input type="hidden" id="cropWidth" value="${selectedNode.data?.roi_regions?.[0]?.width || 640}">
                        <input type="hidden" id="cropHeight" value="${selectedNode.data?.roi_regions?.[0]?.height || 480}">

                        <!-- 视频源选择 -->
                        <div class="mb-3">
                            <label class="block text-xs font-semibold text-gray-600 mb-2">选择视频源</label>
                            <select id="cropVideoSourceSelect" class="w-full px-2 py-1 border border-gray-200 rounded text-xs mb-2"
                                onchange="handleVideoSourceChange()">
                                <option value="">-- 请选择视频源 --</option>
                            </select>
                            <button onclick="loadImageForCrop()" id="btnLoadCropImage" class="w-full px-3 py-2 bg-blue-500 text-white rounded-lg text-xs hover:bg-blue-600 transition-all">
                                <i class="fas fa-camera mr-1"></i>加载当前帧
                            </button>
                        </div>

                        <!-- Canvas绘制区域 -->
                        <div id="cropCanvasContainer" class="hidden">
                            <div class="relative border-2 border-dashed border-gray-300 rounded-lg overflow-hidden bg-gray-900">
                                <canvas id="cropCanvas" class="w-full cursor-crosshair"></canvas>
                            </div>

                            <!-- 操作按钮 -->
                            <div class="flex space-x-2 mt-2">
                                <button onclick="clearCropPolygon()" class="flex-1 px-2 py-1 bg-red-50 text-red-600 rounded text-xs hover:bg-red-100 transition-all">
                                    <i class="fas fa-trash mr-1"></i>清除
                                </button>
                                <button onclick="undoCropPoint()" class="flex-1 px-2 py-1 bg-yellow-50 text-yellow-600 rounded text-xs hover:bg-yellow-100 transition-all">
                                    <i class="fas fa-undo mr-1"></i>撤销
                                </button>
                                <button onclick="completeCropPolygon()" class="flex-1 px-2 py-1 bg-green-50 text-green-600 rounded text-xs hover:bg-green-100 transition-all">
                                    <i class="fas fa-check mr-1"></i>完成
                                </button>
                            </div>

                            <!-- 多边形信息 -->
                            <div class="mt-2 p-2 bg-gray-50 rounded text-xs">
                                <p class="font-semibold text-gray-700 mb-1">多边形顶点：</p>
                                <div id="cropPolygonPoints" class="text-gray-600 max-h-20 overflow-y-auto">
                                    <p class="text-gray-400">点击图片添加顶点...</p>
                                </div>
                            </div>

                            <!-- 外接矩形信息 -->
                            <div id="cropBoundingBoxInfo" class="mt-2 hidden p-2 bg-blue-50 rounded text-xs">
                                <p class="font-semibold text-blue-700 mb-1">外接矩形：</p>
                                <p class="text-blue-600" id="cropBoundingText"></p>
                            </div>
                        </div>

                        <div id="cropNoImageHint" class="p-4 text-center text-gray-400 border-2 border-dashed border-gray-300 rounded-lg">
                            <i class="fas fa-image text-2xl mb-2"></i>
                            <p class="text-xs">请先选择视频源并加载图片</p>
                        </div>

                        <div class="mt-3 p-2 bg-orange-50 rounded-lg">
                            <p class="text-xs text-orange-700">
                                <i class="fas fa-info-circle mr-1"></i>
                                绘制的热区坐标将传递给后续算法节点使用
                            </p>
                        </div>

                        <!-- 保存按钮 -->
                        <button onclick="saveCropConfig()" class="w-full mt-3 px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg text-sm font-medium transition-all">
                            <i class="fas fa-save mr-1"></i>保存热区配置
                        </button>
                    </div>
                ` : ''}
            </div>
        `;

        // 如果是roi或crop节点，自动查找并加载前置视频源
        if (selectedNode.type === 'roi' || selectedNode.type === 'crop') {
            setTimeout(() => {
                const selectEl = document.getElementById('cropVideoSourceSelect');

                // 填充视频源下拉列表（无论是否已有选项，都重新填充以确保最新）
                if (selectEl) {
                    selectEl.innerHTML = '<option value="">-- 请选择视频源 --</option>' +
                        resources.sources.map(s => {
                            const statusIcon = s.status === 'RUNNING' ? '🟢' : '⚫';
                            return `<option value="${s.id}">${statusIcon} ${s.name}</option>`;
                        }).join('');
                }

                // 自动查找前置视频源节点
                const inputConnection = connections.find(c => c.to === selectedNode.id);
                let autoSourceId = null;
                let autoSourceName = null;

                if (inputConnection) {
                    const sourceNode = nodes.find(n => n.id === inputConnection.from);
                    if (sourceNode && sourceNode.type === 'source') {
                        autoSourceId = sourceNode.dataId;
                        autoSourceName = sourceNode.name;
                    }
                }

                // 检查是否已有多边形配置，如果有则回显
                const existingPolygon = selectedNode.data?.roi_regions?.[0]?.polygon;
                const hasPolygon = existingPolygon && existingPolygon.length >= 3;

                console.log('🔍 热区回显检查:', {
                    nodeId: selectedNode.id,
                    nodeName: selectedNode.name,
                    hasPolygon: hasPolygon,
                    polygonPoints: hasPolygon ? existingPolygon.length : 0,
                    roi_regions: selectedNode.data?.roi_regions
                });

                if (hasPolygon) {
                    // 将多边形配置转换为cropPolygonPoints格式
                    cropPolygonPoints = existingPolygon.map((point, index) => ({
                        canvasX: point[0], // 暂时使用原始坐标，加载图片后会重新计算
                        canvasY: point[1],
                        x: point[0],
                        y: point[1],
                        closed: index === 0 ? true : undefined // 标记为已闭合
                    }));
                    console.log('✅ 多边形数据已加载:', cropPolygonPoints.length, '个顶点');
                }

                // 自动加载视频源（优先使用前置节点连接的视频源）
                if (autoSourceId) {
                    selectEl.value = autoSourceId;
                    loadImageForCrop(hasPolygon); // 如果有多边形配置则是回显模式
                    console.log(`✓ 自动加载前置视频源: ${autoSourceName || autoSourceId}`);
                } else if (hasPolygon && resources.sources.length > 0) {
                    // 如果没有前置视频源但有多边形配置，加载第一个视频源
                    const firstSource = resources.sources[0];
                    selectEl.value = firstSource.id;
                    loadImageForCrop(true);
                } else {
                    // 没有找到前置视频源节点，显示友好提示
                    console.log('💡 提示: 请先连接视频源节点，或手动选择视频源加载图片');
                    const hintEl = document.getElementById('cropNoImageHint');
                    if (hintEl) {
                        hintEl.innerHTML = `
                            <i class="fas fa-link text-2xl mb-2"></i>
                            <p class="text-xs mt-2">请先在画布上连接视频源节点</p>
                            <p class="text-xs text-gray-500 mt-1">或从下拉列表手动选择视频源</p>
                        `;
                    }
                }
            }, 100); // 增加延迟确保DOM完全渲染
        }
    }

    // 更新窗口检测配置
    function updateWindowConfig(key, value) {
        if (!selectedNode.data) {
            selectedNode.data = {};
        }
        if (!selectedNode.data.config) {
            selectedNode.data.config = {};
        }
        if (!selectedNode.data.config.window_detection) {
            selectedNode.data.config.window_detection = {};
        }

        selectedNode.data.config.window_detection[key] = value;
    }

    // 重置窗口检测配置为默认值
    function resetWindowDetectionConfig() {
        if (!selectedNode.data) {
            selectedNode.data = {};
        }
        if (!selectedNode.data.config) {
            selectedNode.data.config = {};
        }

        // 清空配置，将使用算法默认值
        delete selectedNode.data.config.window_detection;
        renderPropertiesPanel();
        showMessage('已重置为算法默认配置', 'success');
    }

    // 添加ROI区域
    function addROI() {
        if (!selectedNode.data) {
            selectedNode.data = {};
        }
        if (!selectedNode.data.config) {
            selectedNode.data.config = {};
        }
        if (!selectedNode.data.config.roi_regions) {
            selectedNode.data.config.roi_regions = [];
        }

        const roiName = prompt('请输入ROI区域名称:', '区域' + (selectedNode.data.config.roi_regions.length + 1));
        if (!roiName) return;

        selectedNode.data.config.roi_regions.push({
            name: roiName,
            polygon: [[0, 0], [100, 0], [100, 100], [0, 100]],
            mode: 'post_filter'
        });

        renderPropertiesPanel();
    }

    // 删除ROI区域
    function removeROI(index) {
        if (!selectedNode.data?.config?.roi_regions) return;

        selectedNode.data.config.roi_regions.splice(index, 1);
        renderPropertiesPanel();
    }

    // 保存节点配置
    function saveNodeConfig() {
        if (!selectedNode) return;

        // 更新nodes数组中的节点数据
        const nodeIndex = nodes.findIndex(n => n.id === selectedNode.id);
        if (nodeIndex !== -1) {
            nodes[nodeIndex].data = nodes[nodeIndex].data || {};
            nodes[nodeIndex].data.config = selectedNode.data?.config || {};

            // 如果config为空对象，删除它
            if (Object.keys(nodes[nodeIndex].data.config).length === 0) {
                delete nodes[nodeIndex].data.config;
            }
        }

        showMessage('节点配置已更新，请点击右上角"保存"按钮保存工作流', 'success');
    }

    // 保存裁剪节点配置（同时支持 roi 和 crop 类型）
    function saveCropConfig() {
        if (!selectedNode || (selectedNode.type !== 'crop' && selectedNode.type !== 'roi')) return;

        // 检查是否已完成多边形绘制
        if (cropPolygonPoints.length < 3 || !isPolygonClosed()) {
            showMessage('请先完成多边形绘制（至少3个顶点）', 'warning');
            return;
        }

        // 从多边形计算外接矩形
        const bbox = calculateBoundingBox(cropPolygonPoints);

        // 更新隐藏输入框的值
        document.getElementById('cropX').value = bbox.x;
        document.getElementById('cropY').value = bbox.y;
        document.getElementById('cropWidth').value = bbox.width;
        document.getElementById('cropHeight').value = bbox.height;

        // 保存多边形顶点到节点配置
        const nodeIndex = nodes.findIndex(n => n.id === selectedNode.id);
        if (nodeIndex !== -1) {
            nodes[nodeIndex].data = nodes[nodeIndex].data || {};
            nodes[nodeIndex].data.roi_regions = [{
                x: bbox.x,
                y: bbox.y,
                width: bbox.width,
                height: bbox.height,
                polygon: cropPolygonPoints.map(p => [p.x, p.y])
            }];
        }

        const nodeTypeText = selectedNode.type === 'roi' ? '热区' : '裁剪';
        showMessage(`${nodeTypeText}配置已保存（基于多边形外接矩形），共${cropPolygonPoints.length}个顶点`, 'success');
    }

    // 图形化配置相关变量
    let cropPolygonPoints = [];
    let cropCanvas = null;
    let cropCtx = null;
    let cropImage = null;
    let cropCanvasScale = 1;

    // 处理视频源选择变化
    function handleVideoSourceChange() {
        const selectEl = document.getElementById('cropVideoSourceSelect');
        const taskId = selectEl.value;

        if (!taskId) {
            // 用户选择了"请选择"，清空Canvas
            cropPolygonPoints = [];
            cropCanvas = null;
            cropCtx = null;
            cropImage = null;

            document.getElementById('cropCanvasContainer').classList.add('hidden');
            document.getElementById('cropNoImageHint').classList.remove('hidden');
            return;
        }

        // 自动加载选中视频源的图片（清空之前的多边形，因为坐标可能不匹配）
        cropPolygonPoints = [];
        loadImageForCrop(false);
    }

    // 从视频源加载图片用于裁剪配置
    async function loadImageForCrop(isRestore = false) {
        const selectEl = document.getElementById('cropVideoSourceSelect');
        const taskId = selectEl.value;

        if (!taskId) {
            showMessage('请先选择视频源', 'warning');
            return;
        }

        const btn = document.getElementById('btnLoadCropImage');
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>加载中...';

        try {
            const response = await fetch(`/api/workflows/capture_frame/${taskId}`);
            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || '加载失败');
            }

            // 创建图片对象
            cropImage = new Image();
            cropImage.onload = function() {
                initCropCanvas(isRestore);
                btn.disabled = false;
                btn.innerHTML = '<i class="fas fa-camera mr-1"></i>重新加载';

                // 显示Canvas，隐藏提示
                document.getElementById('cropCanvasContainer').classList.remove('hidden');
                document.getElementById('cropNoImageHint').classList.add('hidden');

                if (isRestore) {
                    showMessage('已加载已有配置，可以继续编辑', 'success');
                } else {
                    showMessage('图片加载成功，点击图片添加多边形顶点', 'success');
                }
            };
            cropImage.src = result.image;

        } catch (error) {
            showMessage('加载失败: ' + error.message, 'error');
            btn.disabled = false;
            btn.innerHTML = '<i class="fas fa-camera mr-1"></i>加载当前帧';
        }
    }

    // 初始化Canvas
    function initCropCanvas(isRestore = false) {
        cropCanvas = document.getElementById('cropCanvas');
        cropCtx = cropCanvas.getContext('2d');

        // 设置Canvas尺寸（限制最大宽度）
        const maxWidth = 280;
        const scale = Math.min(1, maxWidth / cropImage.width);
        cropCanvasScale = scale;

        cropCanvas.width = cropImage.width * scale;
        cropCanvas.height = cropImage.height * scale;

        // 如果是回显模式，重新计算canvas坐标
        if (isRestore && cropPolygonPoints.length > 0) {
            cropPolygonPoints = cropPolygonPoints.map(p => ({
                ...p,
                canvasX: p.x * scale,  // 重新计算canvas坐标
                canvasY: p.y * scale
            }));
        } else {
            // 新建模式，清空多边形
            cropPolygonPoints = [];
        }

        // 绘制图片和多边形
        drawCropCanvas();
        updatePolygonInfo();

        // 如果是回显模式且多边形已闭合，显示外接矩形信息
        if (isRestore && cropPolygonPoints.length >= 3 && isPolygonClosed()) {
            const bbox = calculateBoundingBox(cropPolygonPoints);
            document.getElementById('cropBoundingText').textContent =
                `X: ${bbox.x}, Y: ${bbox.y}, 宽度: ${bbox.width}, 高度: ${bbox.height}`;
            document.getElementById('cropBoundingBoxInfo').classList.remove('hidden');
        }

        // 绑定点击事件
        cropCanvas.onclick = handleCropCanvasClick;
        cropCanvas.ondblclick = handleCropCanvasDoubleClick;
    }

    // 绘制Canvas
    function drawCropCanvas() {
        if (!cropCtx || !cropImage) return;

        // 清空
        cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);

        // 绘制图片
        cropCtx.drawImage(cropImage, 0, 0, cropCanvas.width, cropCanvas.height);

        // 绘制多边形
        if (cropPolygonPoints.length > 0) {
            cropCtx.strokeStyle = '#00FF00';
            cropCtx.lineWidth = 2;
            cropCtx.fillStyle = 'rgba(0, 255, 0, 0.2)';

            cropCtx.beginPath();
            // 使用canvas坐标
            cropCtx.moveTo(cropPolygonPoints[0].canvasX, cropPolygonPoints[0].canvasY);

            for (let i = 1; i < cropPolygonPoints.length; i++) {
                cropCtx.lineTo(cropPolygonPoints[i].canvasX, cropPolygonPoints[i].canvasY);
            }

            // 如果已完成绘制，闭合路径并填充
            if (cropPolygonPoints.length >= 3 && isPolygonClosed()) {
                cropCtx.closePath();
                cropCtx.fill();
            } else if (cropPolygonPoints.length >= 2) {
                // 未完成时也显示半透明填充效果
                cropCtx.lineTo(cropPolygonPoints[0].canvasX, cropPolygonPoints[0].canvasY);
                cropCtx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                cropCtx.fill();
                // 重新开始路径，只绘制边框
                cropCtx.beginPath();
                cropCtx.moveTo(cropPolygonPoints[0].canvasX, cropPolygonPoints[0].canvasY);
                for (let i = 1; i < cropPolygonPoints.length; i++) {
                    cropCtx.lineTo(cropPolygonPoints[i].canvasX, cropPolygonPoints[i].canvasY);
                }
            }

            cropCtx.stroke();

            // 绘制顶点
            cropPolygonPoints.forEach((point, index) => {
                cropCtx.fillStyle = index === 0 ? '#FF0000' : '#00FF00';
                cropCtx.beginPath();
                cropCtx.arc(point.canvasX, point.canvasY, 4, 0, 2 * Math.PI);
                cropCtx.fill();

                // 绘制顶点序号
                cropCtx.fillStyle = '#FFFFFF';
                cropCtx.font = '10px Arial';
                cropCtx.textAlign = 'center';
                cropCtx.textBaseline = 'middle';
                cropCtx.fillText(index + 1, point.canvasX, point.canvasY);
            });
        }
    }

    // 处理Canvas点击
    function handleCropCanvasClick(event) {
        if (cropPolygonPoints.length >= 3 && isPolygonClosed()) {
            showMessage('多边形已完成绘制，请先清除或撤销', 'warning');
            return;
        }

        const rect = cropCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // 保存Canvas坐标（用于显示），同时记录实际坐标
        cropPolygonPoints.push({
            canvasX: x,
            canvasY: y,
            x: Math.round(x / cropCanvasScale),
            y: Math.round(y / cropCanvasScale)
        });
        drawCropCanvas();
        updatePolygonInfo();
    }

    // 处理Canvas双击
    function handleCropCanvasDoubleClick(event) {
        event.preventDefault();
        if (cropPolygonPoints.length >= 3) {
            completeCropPolygon();
        }
    }

    // 检查多边形是否已闭合
    function isPolygonClosed() {
        return cropPolygonPoints.length >= 3 && cropPolygonPoints[0].closed;
    }

    // 清除多边形
    function clearCropPolygon() {
        cropPolygonPoints = [];
        drawCropCanvas();
        updatePolygonInfo();
        document.getElementById('cropBoundingBoxInfo').classList.add('hidden');
        showMessage('已清除多边形', 'success');
    }

    // 撤销最后一个点
    function undoCropPoint() {
        if (cropPolygonPoints.length > 0) {
            cropPolygonPoints.pop();
            drawCropCanvas();
            updatePolygonInfo();
            document.getElementById('cropBoundingBoxInfo').classList.add('hidden');
        }
    }

    // 完成多边形绘制
    function completeCropPolygon() {
        if (cropPolygonPoints.length < 3) {
            showMessage('至少需要3个顶点才能构成多边形', 'warning');
            return;
        }

        // 标记多边形为已闭合
        cropPolygonPoints[0].closed = true;
        drawCropCanvas();

        // 计算外接矩形
        const bbox = calculateBoundingBox(cropPolygonPoints);

        // 显示外接矩形信息
        document.getElementById('cropBoundingText').textContent =
            `X: ${bbox.x}, Y: ${bbox.y}, 宽度: ${bbox.width}, 高度: ${bbox.height}`;
        document.getElementById('cropBoundingBoxInfo').classList.remove('hidden');

        showMessage('多边形绘制完成！已计算外接矩形', 'success');
    }

    // 计算外接矩形
    function calculateBoundingBox(points) {
        const xs = points.map(p => p.x);
        const ys = points.map(p => p.y);

        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);

        return {
            x: Math.round(minX),
            y: Math.round(minY),
            width: Math.round(maxX - minX),
            height: Math.round(maxY - minY)
        };
    }

    // 更新多边形信息显示
    function updatePolygonInfo() {
        const container = document.getElementById('cropPolygonPoints');

        if (cropPolygonPoints.length === 0) {
            container.innerHTML = '<p class="text-gray-400">点击图片添加顶点...</p>';
        } else {
            container.innerHTML = cropPolygonPoints.map((p, i) => `
                <div class="flex items-center justify-between py-1">
                    <span class="font-medium">顶点 ${i + 1}${i === 0 ? ' (起点)' : ''}</span>
                    <span class="text-gray-600">(${p.x}, ${p.y})</span>
                </div>
            `).join('');
        }
    }

    function startNodeDrag(e, nodeId) {
        draggedNode = nodes.find(n => n.id === nodeId);
        if (!draggedNode) return;
        
        const nodeEl = document.querySelector(`[data-node-id="${nodeId}"]`);
        const rect = nodeEl.getBoundingClientRect();
        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
        
        const offsetX = e.clientX - rect.left;
        const offsetY = e.clientY - rect.top;
        
        function onMouseMove(e) {
            if (!draggedNode) return;
            
            draggedNode.x = e.clientX - canvasRect.left - offsetX;
            draggedNode.y = e.clientY - canvasRect.top - offsetY;
            
            nodeEl.style.left = draggedNode.x + 'px';
            nodeEl.style.top = draggedNode.y + 'px';
            
            renderConnections();
            renderPropertiesPanel();
        }
        
        function onMouseUp() {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            draggedNode = null;
        }
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    function renderConnections() {
        const svg = document.getElementById('connectionsSvg');
        const defs = svg.querySelector('defs');
        
        // 清空SVG但保留defs
        if (defs) {
            svg.innerHTML = defs.outerHTML;
        } else {
            // 如果defs不存在，重新创建
            svg.innerHTML = `
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                        <polygon points="0 0, 10 3, 0 6" fill="#4B5563" />
                    </marker>
                </defs>
            `;
        }
        
        console.log('渲染连线:', connections.length, '条');
        
        connections.forEach((conn, index) => {
            const fromNode = nodes.find(n => n.id === conn.from);
            const toNode = nodes.find(n => n.id === conn.to);
            
            if (!fromNode || !toNode) {
                console.warn(`连线 ${index} 找不到节点:`, {
                    from: conn.from, 
                    to: conn.to,
                    fromNode: !!fromNode,
                    toNode: !!toNode
                });
                return;
            }
            
            const fromEl = document.querySelector(`[data-node-id="${conn.from}"]`);
            const toEl = document.querySelector(`[data-node-id="${conn.to}"]`);
            
            if (!fromEl || !toEl) {
                console.warn(`连线 ${index} 找不到DOM元素:`, {
                    from: conn.from,
                    to: conn.to,
                    fromEl: !!fromEl,
                    toEl: !!toEl
                });
                return;
            }
            
            const fromRect = fromEl.getBoundingClientRect();
            const toRect = toEl.getBoundingClientRect();
            const canvasRect = document.getElementById('canvas').getBoundingClientRect();
            
            // 计算起点坐标（根据fromPort）
            let x1, y1;
            if (conn.fromPort === 'true') {
                x1 = fromRect.right - canvasRect.left;
                y1 = fromRect.top + fromRect.height * 0.3 - canvasRect.top;
            } else if (conn.fromPort === 'false') {
                x1 = fromRect.right - canvasRect.left;
                y1 = fromRect.top + fromRect.height * 0.7 - canvasRect.top;
            } else {
                x1 = fromRect.right - canvasRect.left;
                y1 = (fromRect.top + fromRect.bottom) / 2 - canvasRect.top;
            }
            
            const x2 = toRect.left - canvasRect.left;
            const y2 = (toRect.top + toRect.bottom) / 2 - canvasRect.top;
            
            const midX = (x1 + x2) / 2;
            
            console.log(`连线 ${index}: (${x1.toFixed(1)}, ${y1.toFixed(1)}) -> (${x2.toFixed(1)}, ${y2.toFixed(1)})`);
            
            // 创建路径
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let pathClass = 'connection-line';
            if (conn.condition === 'detected') {
                pathClass += ' detected';
            } else if (conn.condition === 'not_detected') {
                pathClass += ' not-detected';
            }
            path.setAttribute('class', pathClass);
            path.setAttribute('d', `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`);
            
            svg.appendChild(path);
            console.log(`已添加路径元素，class=${pathClass}`);
            
            // 添加标签（如果有条件）
            if (conn.label) {
                const labelX = midX;
                const labelY = (y1 + y2) / 2;
                
                // 背景矩形
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('class', 'connection-label-bg ' + (conn.condition === 'detected' ? 'detected' : 'not-detected'));
                rect.setAttribute('x', labelX - 25);
                rect.setAttribute('y', labelY - 10);
                rect.setAttribute('width', 50);
                rect.setAttribute('height', 20);
                svg.appendChild(rect);
                
                // 文字
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('class', 'connection-label');
                text.setAttribute('x', labelX);
                text.setAttribute('y', labelY + 4);
                text.setAttribute('text-anchor', 'middle');
                text.textContent = conn.label;
                svg.appendChild(text);
            }
        });
    }

    function handleDragStart(event) {
        const type = event.target.dataset.type;
        const dataId = event.target.dataset.id;
        const name = event.target.dataset.name;
        const subtype = event.target.dataset.subtype;
        
        event.dataTransfer.setData('type', type);
        event.dataTransfer.setData('dataId', dataId || '');
        event.dataTransfer.setData('name', name || '');
        event.dataTransfer.setData('subtype', subtype || '');
    }

    function handleDragOver(event) {
        event.preventDefault();
    }

    function handleDrop(event) {
        event.preventDefault();
        
        const type = event.dataTransfer.getData('type');
        const dataId = event.dataTransfer.getData('dataId');
        const name = event.dataTransfer.getData('name');
        const subtype = event.dataTransfer.getData('subtype');
        
        const canvasRect = document.getElementById('canvas').getBoundingClientRect();
        const x = event.clientX - canvasRect.left - 90; // 90 = 节点宽度的一半
        const y = event.clientY - canvasRect.top - 40;  // 40 = 节点高度的一半
        
        let nodeName = name;
        if (!nodeName) {
            if (type === 'output') {
                nodeName = subtype === 'alert' ? '告警输出' : '录像输出';
            } else if (type === 'condition') {
                nodeName = subtype === 'detection' ? '检测条件' : '条件分支';
            } else if (type === 'roi') {
                nodeName = '热区绘制';
            } else {
                nodeName = '未命名';
            }
        }
        
        const node = {
            id: 'node_' + (++nodeIdCounter) + '_' + Date.now(),
            type: type,
            subtype: subtype || null,
            name: nodeName,
            dataId: dataId || null,
            x: Math.max(0, x),
            y: Math.max(0, y)
        };
        
        nodes.push(node);
        renderCanvas();
    }

    function deleteNode(nodeId) {
        if (!confirm('确定要删除这个节点吗？相关连线也会被删除。')) return;
        
        nodes = nodes.filter(n => n.id !== nodeId);
        // 同时删除所有相关的连线
        connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
        selectedNode = null;
        renderCanvas();
        renderPropertiesPanel();
    }

    function startConnection(event, nodeId, connectorType) {
        event.stopPropagation();
        
        // 如果是输出连接点（output, true, false）
        if (['output', 'true', 'false'].includes(connectorType)) {
            isConnecting = true;
            connectionStart = { 
                nodeId: nodeId, 
                port: connectorType,
                condition: connectorType === 'true' ? 'detected' : connectorType === 'false' ? 'not_detected' : null
            };
        } else if (connectorType === 'input') {
            // 如果点击的是 input，查找是否有连到这个节点的连线
            const existingConn = connections.find(c => c.to === nodeId);
            if (existingConn) {
                // 删除连线
                connections = connections.filter(c => c !== existingConn);
                renderConnections();
            }
        }
        
        document.addEventListener('mouseup', endConnection);
    }

    function endConnection(event) {
        if (!isConnecting || !connectionStart) {
            isConnecting = false;
            connectionStart = null;
            document.removeEventListener('mouseup', endConnection);
            return;
        }
        
        // 查找鼠标释放位置的节点
        const element = document.elementFromPoint(event.clientX, event.clientY);
        const connector = element?.closest('.node-connector.input');
        
        if (connector) {
            const nodeEl = connector.closest('.workflow-node');
            const toNodeId = nodeEl.dataset.nodeId;
            const toPort = connector.dataset.port || 'input';
            
            // 检查是否是有效连接
            if (toNodeId !== connectionStart.nodeId) {
                // 检查是否已存在相同的连接
                const exists = connections.some(c => 
                    c.from === connectionStart.nodeId && 
                    c.to === toNodeId && 
                    c.fromPort === connectionStart.port
                );
                
                if (!exists) {
                    const connection = {
                        from: connectionStart.nodeId,
                        to: toNodeId,
                        fromPort: connectionStart.port,
                        toPort: toPort,
                        condition: connectionStart.condition,
                        label: connectionStart.condition === 'detected' ? '检测到' : 
                               connectionStart.condition === 'not_detected' ? '未检测到' : null
                    };
                    
                    connections.push(connection);
                    renderConnections();
                }
            }
        }
        
        isConnecting = false;
        connectionStart = null;
        document.removeEventListener('mouseup', endConnection);
    }

    function closeEditor() {
        if (confirm('确定要关闭编辑器吗？未保存的更改将丢失。')) {
            document.getElementById('editorModal').classList.add('hidden');
            currentWorkflow = null;
            nodes = [];
            connections = [];
            selectedNode = null;
        }
    }

    async function saveWorkflow() {
        if (!currentWorkflow) return;
        
        const saveData = {
            workflow_data: {
                nodes: nodes,
                connections: connections
            }
        };
        
        console.log('保存算法编排数据:', {
            nodes: nodes.length,
            connections: connections.length,
            data: saveData
        });
        
        try {
            await apiRequest(`/api/workflows/${currentWorkflow.id}`, 'PUT', saveData);
            
            showMessage('算法编排保存成功');
        } catch (error) {
            showMessage('保存失败: ' + error.message, 'error');
        }
    }

    async function activateWorkflow(id) {
        try {
            await apiRequest(`/api/workflows/${id}/activate`, 'POST');
            showMessage('算法编排已激活');
            loadWorkflows();
        } catch (error) {
            showMessage('激活失败: ' + error.message, 'error');
        }
    }

    async function deactivateWorkflow(id) {
        try {
            await apiRequest(`/api/workflows/${id}/deactivate`, 'POST');
            showMessage('算法编排已停用');
            loadWorkflows();
        } catch (error) {
            showMessage('停用失败: ' + error.message, 'error');
        }
    }

    async function deleteWorkflow(id) {
        if (!confirm('确定要删除这个算法编排吗？此操作不可撤销。')) return;
        
        try {
            await apiRequest(`/api/workflows/${id}`, 'DELETE');
            showMessage('算法编排删除成功');
            loadWorkflows();
        } catch (error) {
            showMessage('删除失败: ' + error.message, 'error');
        }
    }

    // 页面加载时初始化
    loadWorkflows();
</script>
{% endblock %}

